options
{
  LOOKAHEAD=1;
}

PARSER_BEGIN(Parser)

import java.io.*;

public class Parser
{
	public static void main(String args[]) throws ParseException, IOException {
		if(args.length != 1){
			System.out.println("Usage: Parser <file.yal>");
			return;
		}
		String filename = args[0];
		try{

			BufferedReader br = new BufferedReader(new FileReader(filename));
			Parser simpleParser = new Parser(br);
			SimpleNode root = simpleParser.Module();
	  		root.dump("");

	  	}catch(IOException e){
	  		e.printStackTrace();
	  	}
	}
}

PARSER_END(Parser)

SKIP:
{
	" "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* reserved words */
TOKEN : {
<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}

TOKEN : {
<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

SimpleNode Module() : { }
{
	<MODULE>Id()<LCHAVETA>(Declaration())*(Function())*<RCHAVETA> { return jjtThis; }
}
void Declaration() : { }
{
	(ScalarElement())( <ASSIGN> ( ( "[" ArraySize() "]" ) | (<ADDSUB_OP> )? <INTEGER> ) )? <PVIRG>
}

void Function() : { }
{
	  <FUNCTION> Function2()#Return(>1) <LPAR> ( Varlist()#Parameters )? <RPAR>  <LCHAVETA> Stmtlst() <RCHAVETA>
}

void Function2() #void : { Token id; }
{
	 Id() ((ArrayElement())?<ASSIGN>  Id())?
}

void Function3() #void : { }
{
  (ArrayElement())?<ASSIGN>  Id()
}

void Id() : { Token id; }
{
 id=< ID > { jjtThis.val = id.image; }
}
void Integer() : { Token integer; }
{
	integer=< INTEGER > { jjtThis.val = integer.image;}
}

void Varlist()#void: { }
{
	(  ScalarElement() ) ( <VIRG> ( ScalarElement() ) )*
}

void ScalarElement()#void: { }
{
	Id() (ArrayElement())?
}
void ArrayElement(): { }
{
	"[""]"
}
void Stmtlst() #void : { }
{
	(Stmt())*
}
void Stmt()#void: { }
{
	While() | If() | (LOOKAHEAD(Call()) Call() < PVIRG > | Assign())   //ID
}
void Call(): {}
{
	 Id() ( "." Id() )? <LPAR> ( ArgumentList() )? <RPAR>
}
void Assign(): { Token assign; }
{
	Lhs()#Array(>1) assign=< ASSIGN > { jjtThis.val = assign.image; }Rhs()<PVIRG>
}
void Lhs() #void : { }
{
	Id() (ArrayAccess() | ScalarAccess())
}
void Rhs() #void : { }
{
	( Term() ( ( <ARITH_OP> | <BITWISE_OP> | <ADDSUB_OP> ) Term() )? )| "[" ArraySize() "]"
}

void ArrayAccess():{ Token ind = new Token(); ind.image = "undefined"; } // -- ID
{
	"[" (ind=< ID >| ind=< INTEGER >)? "]" { jjtThis.val = ind.image=="undefined"?"[]":"["+ind.image+"]"; } //Optional Index. Now accepts statement b[] = 2; 
}
void ScalarAccess()#void:{} // -- ID
{
	 ("." <SIZE>)? 
}

void ArraySize(): { } // ++ ID
{
	Id() ScalarAccess() | Integer()
}
void Term()#void: { }
{
	( <ADDSUB_OP> )? ( Integer() | LOOKAHEAD(Call()) Call() | Id() ( ArrayAccess() | ScalarAccess())) // ID
}

void Exprtest(): { Token RelOp; }
{
	<LPAR> Lhs() RelOp=<RELA_OP> { jjtThis.val = RelOp.image; } Rhs() <RPAR>
}
void While(): { }
{
	<WHILE> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>
}
void If(): {}
{
	<IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA> ( <ELSE> <LCHAVETA> Stmtlst()#Else <RCHAVETA> )?
}
void ArgumentList():{}
{
	Argument() ( <VIRG> Argument() )*
}
void Argument():{}
{
	( Id() | <STRING> | Integer() )
}

Token Index():{Token t;}
{
	(t=< ID >| t=< INTEGER >) { return t; }
}